# データベース設計書

**プロジェクト名**: Gemini Vision Scanner
**バージョン**: 2.0.0
**作成日**: 2026-02-24

---

## 1. データ永続化の概要

本プロジェクトはRDBMSを使用しない。レート制限の状態管理のみがサーバー側のデータストアを必要とし、Redis（マルチプロセス対応）またはインメモリ（シングルプロセス用フォールバック）を自動選択する。

### バックエンド選択ロジック

```
起動時:
  ├── REDIS_URL 環境変数が設定されている場合
  │     ├── Redis接続成功 → RedisRateLimiter を使用
  │     └── Redis接続失敗 → InMemoryRateLimiter にフォールバック（警告ログ出力）
  └── REDIS_URL 未設定 → InMemoryRateLimiter を使用
```

遅延初期化（`_get_backend()`）により、最初のリクエスト時にバックエンドを決定する。

---

## 2. Redisデータ構造

### 2.1 キー命名規則

| キー | 型 | TTL | 用途 |
|------|-----|-----|------|
| `rate:minute:{client_ip}` | Sorted Set | 90秒 | 分単位リクエスト履歴 |
| `rate:daily:{client_ip}:{YYYY-MM-DD}` | String (整数) | 翌日0時まで | 日次リクエストカウント |

**client_ip の構成**:
- `ip_ua`モード: `{IP}:{SHA256(UserAgent[:64])[:8]}` — 例: `192.168.1.1:a3b2c1d0`
- `ip`モード: `{IP}` — 例: `192.168.1.1`

### 2.2 分単位レート制限（Sorted Set）

```
キー: rate:minute:192.168.1.1:a3b2c1d0
型: Sorted Set
メンバー: request_id (UUID hex 12文字)
スコア: タイムスタンプ (Unix epoch, float)
TTL: 90秒
```

| 操作 | Redisコマンド | 説明 |
|------|-------------|------|
| 期限切れ除去 | `ZREMRANGEBYSCORE key -inf (now-60)` | 60秒より古いエントリを削除 |
| カウント取得 | `ZCARD key` | 現在の有効リクエスト数 |
| 最古エントリ取得 | `ZRANGE key 0 0 WITHSCORES` | 待機秒数計算用 |
| 予約追加 | `ZADD key now request_id` | 新規リクエストを登録 |
| 予約取消 | `ZREM key request_id` | 失敗時のロールバック |

### 2.3 日次レート制限（String）

```
キー: rate:daily:192.168.1.1:a3b2c1d0:2026-02-24
型: String (整数値)
TTL: 翌日0時までの残り秒数（_seconds_until_midnight()で計算）
```

| 操作 | Redisコマンド | 説明 |
|------|-------------|------|
| カウント取得 | `GET key` | 今日のリクエスト数 |
| カウント増加 | `INCR key` | リクエスト予約時 |
| カウント減少 | `DECR key` | ロールバック時 |
| TTL設定 | `EXPIRE key ttl` | 初回のみ（TTL < 0の場合） |

### 2.4 Luaスクリプトによる原子操作

#### 予約スクリプト (_LUA_CONSUME)

```lua
-- KEYS: [1]=minute_key, [2]=daily_key
-- ARGV: [1]=now, [2]=request_id, [3]=per_minute, [4]=daily_limit, [5]=daily_ttl
-- 戻り値: [status, payload]
--   status 0: 成功, payload = request_id
--   status 1: 分制限超過, payload = wait_seconds
--   status 2: 日制限超過, payload = 'daily'

1. ZREMRANGEBYSCORE minute_key -inf (now-60)  -- 期限切れ除去
2. GET daily_key → daily_count                 -- 日次チェック
3. daily_count >= daily_limit → return {2, 'daily'}
4. ZCARD minute_key → minute_count             -- 分チェック
5. minute_count >= per_minute → oldest+60-now を計算 → return {1, wait}
6. ZADD minute_key now request_id              -- 予約登録
7. EXPIRE minute_key 90                        -- TTL更新
8. INCR daily_key                              -- 日次カウント増加
9. TTL daily_key < 0 → EXPIRE daily_key ttl   -- 初回TTL設定
10. return {0, request_id}                     -- 成功
```

#### ロールバックスクリプト (_LUA_RELEASE)

```lua
-- KEYS: [1]=minute_key, [2]=daily_key
-- ARGV: [1]=request_id

1. ZREM minute_key request_id → removed        -- 予約取消
2. removed > 0 の場合:
3.   GET daily_key → current
4.   current > 0 → DECR daily_key              -- 日次カウント戻し
```

---

## 3. インメモリデータ構造

### 3.1 TTLCacheの構成

```python
from cachetools import TTLCache

# 分単位レート制限用
_rate_store = TTLCache(maxsize=10_000, ttl=90)
# 値: [(timestamp, request_id), ...]  — リスト形式

# 日次レート制限用
_daily_store = TTLCache(maxsize=10_000, ttl=86400)
# 値: {"date": "YYYY-MM-DD", "count": int}  — 辞書形式
```

### 3.2 データ構造の詳細

#### _rate_store（分単位）

```
キー: client_ip文字列
値: [(timestamp: float, request_id: str), ...]
TTL: 90秒（エントリ単位ではなくキー単位）
```

| 操作 | 処理 | 説明 |
|------|------|------|
| 期限切れ除去 | `[e for e in entries if now - e[0] < 60]` | 60秒以内のエントリのみ保持 |
| カウント取得 | `len(recent)` | 有効リクエスト数 |
| 待機秒数計算 | `oldest_ts + 60 - now + 1` | 最古エントリの期限切れまで |
| 予約追加 | `recent + [(now, request_id)]` | リスト末尾に追加 |
| 予約取消 | `[e for e if e[1] != request_id]` | IDが一致するエントリを除去 |

#### _daily_store（日次）

```
キー: client_ip文字列
値: {"date": "2026-02-24", "count": 15}
TTL: 86400秒（24時間）
```

| 操作 | 処理 | 説明 |
|------|------|------|
| 日付チェック | `daily["date"] != today` | 日付が変わったらカウントリセット |
| カウント増加 | `daily["count"] += 1` | 予約時 |
| カウント減少 | `daily["count"] -= 1` | ロールバック時 |

### 3.3 スレッド安全性

インメモリバックエンドは`threading.Lock()`で排他制御:

```python
self._lock = Lock()

def try_consume(self, client_ip):
    with self._lock:          # ロック取得
        # ... 読み取り・判定・書き込みを一括実行
    return False, "", request_id
```

---

## 4. 予約方式（Reserve-Release）パターン

### 4.1 概要

レート制限は「予約方式」を採用。API呼び出し**前に**カウントを消費し、API失敗時にロールバックする。

```
[1] try_consume_request(rate_key)
    → カウント+1、request_id を発行

[2] detect_content(image_data, mode, ...)
    ├── 成功: ロールバック不要（カウント消費確定）
    └── 失敗: release_request(rate_key, request_id)
              → 指定IDのカウントのみ-1（他リクエストに影響しない）
```

### 4.2 request_idによる安全なロールバック

- 各リクエストに`uuid.uuid4().hex[:12]`のユニークIDを付与
- ロールバック時はIDが一致するエントリのみ除去
- 並行リクエストが存在しても他のリクエストのカウントには影響しない

---

## 5. Redis/インメモリの機能比較

| 機能 | Redis | インメモリ |
|------|-------|---------|
| マルチプロセス対応 | ○（原子操作） | ×（プロセス間で非共有） |
| 原子性保証 | Luaスクリプト | threading.Lock |
| 永続化 | Redis RDB/AOF | なし（プロセス終了で消失） |
| スケーラビリティ | 複数サーバーで共有可 | 単一プロセスのみ |
| 最大クライアント数 | 制限なし | maxsize=10,000 |
| TTL管理 | Redis EXPIRE | cachetools TTLCache |
| フォールバック | - | Redis障害時に自動切替 |

---

## 6. 監視・運用

### 6.1 バックエンド状態確認

```
GET /readyz

レスポンス例:
{
  "status": "ok",
  "checks": {
    "api_key_configured": true,
    "rate_limiter_backend": "redis",   // or "in_memory"
    "rate_limiter_ok": true            // REDIS_URL設定時にin_memoryならfalse
  }
}
```

### 6.2 使用量確認

```
GET /api/config/usage

レスポンス例:
{
  "daily_count": 42,
  "daily_limit": 1000,
  "per_minute_limit": 20
}
```

### 6.3 テスト用リセット

```python
# テストコードでの使用（conftest.py）
from rate_limiter import reset_for_testing
reset_for_testing()  # InMemoryRateLimiterに強制リセット
```
